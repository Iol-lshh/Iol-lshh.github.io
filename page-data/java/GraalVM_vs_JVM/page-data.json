{"componentChunkName":"component---src-templates-blog-post-js","path":"/java/GraalVM_vs_JVM/","result":{"data":{"site":{"siteMetadata":{"title":"Iol-lshh's","siteUrl":"https://iol-lshh.github.io"}},"markdownRemark":{"id":"cc58c280-044b-5655-a4e5-a886ef5bacad","excerpt":"GraalVM이란? GraalVM 특징 네이티브 Java 코드 실행 GraalVM에서 Java 코드 실행 방식 GraalVM 아키텍처 AOT 컴파일 GraalVM vs JVM 1. GraalVM이란? GraalVM은 Ahead-Of-Time (AOT) 컴파일 기능을 가진 고성능 JDK…","html":"<ol>\n<li><strong>GraalVM이란?</strong></li>\n<li><strong>GraalVM 특징</strong></li>\n<li><strong>네이티브 Java 코드 실행</strong></li>\n<li><strong>GraalVM에서 Java 코드 실행 방식</strong></li>\n<li><strong>GraalVM 아키텍처</strong></li>\n<li><strong>AOT 컴파일</strong></li>\n<li><strong>GraalVM vs JVM</strong></li>\n</ol>\n<hr>\n<h2>1. GraalVM이란?</h2>\n<ul>\n<li><strong>GraalVM</strong>은 <strong>Ahead-Of-Time (AOT) 컴파일</strong> 기능을 가진 고성능 JDK입니다.</li>\n<li>기존 JIT 컴파일러를 대체하는 <strong>Graal 컴파일러</strong>를 통해 Java 애플리케이션의 성능을 크게 향상시킵니다.</li>\n<li><strong>애플리케이션 지연(latency)</strong> 을 줄이고, <strong>가비지 컬렉션 시간</strong>을 단축하며, <strong>최대 처리량</strong>을 높입니다.</li>\n</ul>\n<hr>\n<h2>2. GraalVM 특징</h2>\n<ul>\n<li><strong>낮은 리소스 사용</strong>: 네이티브 이미지는 런타임 시 기존 JVM이 필요 없으므로 메모리와 CPU 사용량이 적습니다.</li>\n<li><strong>향상된 보안</strong>: AOT 컴파일 시 정적 분석을 수행하여 런타임 클래스 로딩 및 리플렉션과 같은 공격 표면을 줄입니다.</li>\n<li><strong>빠른 시작</strong>: 네이티브 바이너리는 바이트코드 해석이나 JIT 컴파일이 필요 없으므로 즉시 시작됩니다.</li>\n<li><strong>컴팩트한 패키징</strong>: 네이티브 이미지는 필요한 애플리케이션 코드와 종속성만 포함하여 크기를 줄입니다.</li>\n<li><strong>프레임워크 지원</strong>: Quarkus, Micronaut, Spring Boot와 통합되어 최적화된 애플리케이션 제작 가능.</li>\n<li><strong>클라우드 플랫폼 지원</strong>: AWS Lambda, Google Cloud, Azure 등 주요 플랫폼에서 GraalVM을 지원.</li>\n<li>GraalVM은 <strong>빠른 시작 시간</strong>, <strong>낮은 메모리 사용량</strong>, <strong>네이티브 이미지 생성</strong>, <strong>다중 언어 지원</strong>을 제공하여 뛰어난 선택지로 자리 잡고 있습니다.</li>\n</ul>\n<hr>\n<h2>3. 네이티브 Java 코드 실행</h2>\n<ul>\n<li>GraalVM의 개선점을 살펴보기 전에 <strong>JDK</strong>가 네이티브 Java 코드를 실행하는 방식을 이해해야 합니다.</li>\n</ul>\n<h3>Java의 WORA 원칙</h3>\n<ul>\n<li><strong>WORA</strong>: 한 번 작성하면, 어디서나 실행 가능(Write Once, Run Anywhere).</li>\n<li>Java 코드는 한 번 작성하면, 기계 유형에 상관없이 호환 가능한 JVM에서 실행할 수 있습니다.</li>\n</ul>\n<h3>실행 프로세스</h3>\n<ol>\n<li><strong>소스 코드</strong> → JDK가 이를 <strong>바이트코드</strong>로 컴파일.</li>\n<li><strong>바이트코드</strong> → JVM이 이를 실행.</li>\n<li>JVM 내부 단계:</li>\n</ol>\n<p>   - <strong>클래스 로딩(Class Loading)</strong>: 바이트코드를 로딩하여 실행 준비.\n   - <strong>바이트코드 검증(Byte Code Verification)</strong>: 바이트코드가 안전한지 검증.\n   - <strong>JIT 컴파일(Just-In-Time Compilation)</strong>: 런타임 시 바이트코드를 네이티브 코드로 변환하여 성능 최적화.</p>\n<ul>\n<li><strong>실행 흐름</strong>:  </li>\n<li><code class=\"language-text\">소스 코드 -> JDK -> 바이트코드 -> JVM</code></li>\n</ul>\n<hr>\n<h2>4. GraalVM에서 Java 코드 실행 방식</h2>\n<ul>\n<li>GraalVM은 Java의 기본 실행 방식을 따르지만, <strong>Graal 컴파일러</strong>를 통합하여 JIT 및 AOT 컴파일 성능을 향상시킵니다.</li>\n<li>기존 JVM의 C2 컴파일러를 대체하여 <strong>최적화된 컴파일</strong> 및 <strong>네이티브 이미지 생성</strong>을 지원합니다.</li>\n</ul>\n<hr>\n<h2>5. GraalVM 아키텍처</h2>\n<h3>1. <strong>Java HotSpot VM</strong></h3>\n<ul>\n<li>GraalVM의 기반 계층으로, 다음을 제공합니다:</li>\n</ul>\n<p>  - <strong>JIT 컴파일</strong>\n  - <strong>가비지 컬렉션</strong>\n  - <strong>스레드 관리</strong></p>\n<ul>\n<li>HotSpot VM은 Graal 컴파일러를 통합하여 기존 JVM보다 향상된 성능을 제공합니다.</li>\n</ul>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2af60833174db70a53b2c33bb63a1159/61a6b/IMG_1265.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRm4AAABXRUJQVlA4IGIAAACwAwCdASoUAAgAPtFWpEuoJKOhsAgBABoJQBOmUABfHr3QCtwUAAD+8hLet41lcxyzBe8meeY+NE1QC31nt6XV07NURDgm9OGZgd3tBl5Fgj9jPDYO5ZEmpY6hiaxYd4AAAA=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/2af60833174db70a53b2c33bb63a1159/dc87c/IMG_1265.avif 158w,\n/static/2af60833174db70a53b2c33bb63a1159/383b4/IMG_1265.avif 315w,\n/static/2af60833174db70a53b2c33bb63a1159/d0061/IMG_1265.avif 630w,\n/static/2af60833174db70a53b2c33bb63a1159/fd1e1/IMG_1265.avif 828w\"\n              sizes=\"(max-width: 630px) 100vw, 630px\"\n              type=\"image/avif\"\n            /><source\n              srcset=\"/static/2af60833174db70a53b2c33bb63a1159/5787a/IMG_1265.webp 158w,\n/static/2af60833174db70a53b2c33bb63a1159/89f54/IMG_1265.webp 315w,\n/static/2af60833174db70a53b2c33bb63a1159/4d353/IMG_1265.webp 630w,\n/static/2af60833174db70a53b2c33bb63a1159/61a6b/IMG_1265.webp 828w\"\n              sizes=\"(max-width: 630px) 100vw, 630px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/2af60833174db70a53b2c33bb63a1159/5787a/IMG_1265.webp 158w,\n/static/2af60833174db70a53b2c33bb63a1159/89f54/IMG_1265.webp 315w,\n/static/2af60833174db70a53b2c33bb63a1159/4d353/IMG_1265.webp 630w,\n/static/2af60833174db70a53b2c33bb63a1159/61a6b/IMG_1265.webp 828w\"\n            sizes=\"(max-width: 630px) 100vw, 630px\"\n            type=\"image/webp\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/2af60833174db70a53b2c33bb63a1159/4d353/IMG_1265.webp\"\n            alt=\"graalvm\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>graalvm</p></figcaption>\n  </figure></p>\n<h3>2. <strong>GraalVM 컴파일러 계층</strong></h3>\n<ul>\n<li><strong>다중 언어 JIT 컴파일러</strong>로, Java 및 기타 언어에 최적화된 컴파일을 제공합니다.</li>\n<li><strong>AOT 컴파일</strong>을 지원하여 네이티브 이미지를 생성합니다.</li>\n</ul>\n<h3>3. <strong>언어 구현 프레임워크 계층</strong></h3>\n<ul>\n<li>GraalVM은 여러 프로그래밍 언어를 지원합니다.</li>\n<li><strong>Truffle 프레임워크</strong>와 <strong>LLVM 런타임</strong>을 통해 다중 언어 런타임을 구축할 수 있습니다.</li>\n</ul>\n<hr>\n<h2>6. AOT 컴파일</h2>\n<ul>\n<li><strong>AOT 컴파일(Ahead-Of-Time Compilation)</strong>:</li>\n</ul>\n<p>  - Java 애플리케이션을 런타임 이전에 네이티브 실행 파일로 변환.\n  - <strong>장점</strong>:\n    - 빠른 시작 시간.\n    - 낮은 메모리 사용량.\n    - 런타임 공격 표면 감소로 보안 강화.\n  - Quarkus, Micronaut 같은 프레임워크에서 마이크로서비스를 최적화하는 데 사용됩니다.</p>\n<hr>\n<h2>7. GraalVM vs JVM</h2>\n<table>\n<thead>\n<tr>\n<th><strong>기능</strong>            </th>\n<th><strong>GraalVM</strong>                      </th>\n<th><strong>기존 JVM</strong>  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>시작 시간</strong>        </td>\n<td>매우 빠름 (AOT 네이티브 이미지)</td>\n<td>느림 (JIT 컴파일 필요)        </td>\n</tr>\n<tr>\n<td><strong>메모리 사용량</strong>    </td>\n<td>적음 (네이티브 이미지)           </td>\n<td>많음                         </td>\n</tr>\n<tr>\n<td><strong>성능</strong>            </td>\n<td>향상된 컴파일러로 최적화</td>\n<td>JIT로 최적화되었지만 GraalVM보다는 낮음</td>\n</tr>\n<tr>\n<td><strong>언어 지원</strong></td>\n<td>다중 언어 (Python, Ruby 등)      </td>\n<td>Java 또는 JVM 언어 중심</td>\n</tr>\n<tr>\n<td><strong>애플리케이션 패키징</strong></td>\n<td>컴팩트한 네이티브 실행 파일</td>\n<td>JVM 런타임 필요              </td>\n</tr>\n<tr>\n<td><strong>클라우드 지원</strong></td>\n<td>AWS Lambda 등 주요 플랫폼 지원   </td>\n<td>제한적                       </td>\n</tr>\n</tbody>\n</table>","images":null,"frontmatter":{"title":"GraalVM, JVM 비교","date":"January 14, 2025","description":"GraalVM, JVM 비교","category":["java"],"featuredImage":null}},"previous":{"fields":{"slug":"/pattern/clean_test_suite/"},"frontmatter":{"title":"clean test suite","category":["pattern"]}},"next":{"fields":{"slug":"/java/JVM/"},"frontmatter":{"title":"JVM","category":["java"]}}},"pageContext":{"id":"cc58c280-044b-5655-a4e5-a886ef5bacad","previousPostId":"6b6bfce6-a1e4-5cca-8291-44c193f448a1","nextPostId":"e99784b7-10c5-5a65-8053-261e07be1d73"}},"staticQueryHashes":["1408108323","3764592887","62622001"],"slicesMap":{}}