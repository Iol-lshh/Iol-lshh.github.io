{"componentChunkName":"component---src-templates-blog-post-js","path":"/Db/PG_주의사항/","result":{"data":{"site":{"siteMetadata":{"title":"Iol-lshh's"}},"markdownRemark":{"id":"635243b3-cb2c-588d-8709-a7bc7ba1968c","excerpt":"대부분의 문제는 초기에는 드러나지 않지만, 데이터가 많아지고 쿼리가 복잡해질수록 심각한 성능 문제로 이어질 수 있습니다.…","html":"<ul>\n<li>대부분의 문제는 초기에는 드러나지 않지만, 데이터가 많아지고 쿼리가 복잡해질수록 심각한 성능 문제로 이어질 수 있습니다.</li>\n</ul>\n<hr>\n<h2>1. <code class=\"language-text\">work_mem</code> 기본값을 그대로 사용하기</h2>\n<ul>\n<li><code class=\"language-text\">work_mem</code>은 쿼리 연산이 임시 파일을 디스크에 기록하기 전 사용할 수 있는 메모리 크기를 결정하는 설정입니다.</li>\n<li>기본값을 유지하면 작은 데이터베이스에서는 문제가 없지만, 데이터가 많아지면 성능이 급격히 저하될 수 있습니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li><code class=\"language-text\">pgbadger</code>를 활용해 로그 분석</li>\n<li><code class=\"language-text\">pganalyze</code> 같은 모니터링 시스템 사용</li>\n<li>적절한 <code class=\"language-text\">work_mem</code> 값 계산 및 조정</li>\n<li>특정 트랜잭션에서 <code class=\"language-text\">SET LOCAL work_mem</code>으로 값 조정 가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">work_mem <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>$YOUR_INSTANCE_MEMORY <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span> <span class=\"token operator\">-</span> shared_buffers<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> $YOUR_ACTIVE_CONNECTION_COUNT</code></pre></div>\n<hr>\n<h2>2. 모든 애플리케이션 로직을 Postgres 함수와 프로시저에 넣기</h2>\n<ul>\n<li>PostgreSQL의 함수 및 프로시저는 강력한 기능을 제공하지만, 무분별한 사용은 성능을 저하시킵니다.</li>\n<li>특히 중첩 함수나 재귀 호출은 예상치 못한 지연과 복제 지연(replication lag)을 유발할 수 있습니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li>간단한 함수는 괜찮지만, 가능한 한 <code class=\"language-text\">IMMUTABLE</code> 또는 <code class=\"language-text\">STABLE</code>로 선언</li>\n<li>데이터 구조 조작 및 비즈니스 로직은 애플리케이션 계층에서 처리</li>\n<li>데이터베이스 확장성을 고려하여 부하를 최소화</li>\n</ul>\n<hr>\n<h2>3. 트리거를 과도하게 사용하기</h2>\n<ul>\n<li>트리거는 강력하지만 효율적이지 않습니다.</li>\n<li><code class=\"language-text\">generated columns</code> 또는 <code class=\"language-text\">materialized views</code> 같은 대안을 고려하세요.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li><code class=\"language-text\">BEFORE</code> 트리거와 <code class=\"language-text\">AFTER</code> 트리거를 각각 하나씩만 사용</li>\n<li>트리거 함수명을 통일하고, 모든 로직을 한 함수 내에 유지</li>\n<li>트리거 내부에서 개별적으로 처리하지 말고, 일괄 처리(batch processing)를 활용</li>\n</ul>\n<hr>\n<h2>4. <code class=\"language-text\">NOTIFY</code>를 과도하게 사용하기</h2>\n<ul>\n<li><code class=\"language-text\">NOTIFY</code>는 메시지 큐를 직접 관리하지 않아도 되게 해주지만, 많은 이벤트를 처리할 때는 성능 문제가 발생할 수 있습니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li><code class=\"language-text\">NOTIFY</code> 대신 이벤트를 큐 테이블에 저장하고 일정 간격으로 배치 처리</li>\n<li>이벤트 소비 속도를 조절하여 데이터베이스 부하를 줄이기</li>\n<li>이벤트 처리 후, 데이터를 적절히 정리하여 성능 최적화</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> event_queue <span class=\"token punctuation\">(</span>\n  id uuid <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token keyword\">DEFAULT</span> gen_random_uuid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  user_id uuid <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">REFERENCES</span> users<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">CASCADE</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">type</span> <span class=\"token keyword\">text</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">data</span> jsonb <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  created_at timestamptz <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  occurred_at timestamptz <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  acquired_at timestamptz<span class=\"token punctuation\">,</span>\n  failed_at timestamptz\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> event_queue\n<span class=\"token keyword\">SET</span> acquired_at <span class=\"token operator\">=</span> <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">SELECT</span> id\n  <span class=\"token keyword\">FROM</span> event_queue\n  <span class=\"token keyword\">WHERE</span> acquired_at <span class=\"token operator\">IS</span> <span class=\"token boolean\">NULL</span>\n  <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> occurred_at\n  <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span> SKIP LOCKED\n  <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">1000</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">RETURNING</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>5. <code class=\"language-text\">EXPLAIN ANALYZE</code>를 실데이터에서 실행하기</h2>\n<ul>\n<li><code class=\"language-text\">EXPLAIN ANALYZE</code>는 쿼리를 실제 실행하면서 실행 계획을 보여주기 때문에 프로덕션 환경에서는 조심해서 사용해야 합니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li>프로덕션 데이터의 샘플을 주기적으로 백업하여 별도의 샌드박스 환경에서 분석</li>\n<li><code class=\"language-text\">EXPLAIN</code>을 먼저 실행하고, 필요할 때만 <code class=\"language-text\">ANALYZE</code>를 추가 실행</li>\n<li>샌드박스 환경은 프로덕션보다 작은 크기로 유지하여 성능 문제를 미리 감지</li>\n</ul>\n<hr>\n<h2>6. CTE(Common Table Expressions)를 서브쿼리 대신 사용하세요</h2>\n<ul>\n<li>CTE(예: <code class=\"language-text\">WITH</code> 쿼리)는 직관적이지만, 항상 성능이 더 좋은 것은 아닙니다.</li>\n<li>PostgreSQL 12 이전에는 CTE가 항상 물리적으로 실행되었기 때문에 서브쿼리보다 성능이 낮은 경우가 많았습니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li><code class=\"language-text\">EXPLAIN</code>을 사용하여 CTE와 서브쿼리를 비교</li>\n<li>PostgreSQL 12 이상에서는 최적화가 자동으로 이루어지므로 큰 차이가 없을 수도 있음</li>\n</ul>\n<hr>\n<h2>7. 재귀 CTE를 성능이 중요한 쿼리에 사용하기</h2>\n<ul>\n<li>재귀 CTE는 우아한 해결책이지만, 데이터가 많아질수록 성능 저하가 발생합니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li>데이터 읽기 요청이 많다면, 미리 계산된 결과를 <code class=\"language-text\">materialized view</code> 또는 별도 테이블에 저장하여 조회 속도 최적화</li>\n<li><code class=\"language-text\">SELECT</code> 성능을 높이는 대신, <code class=\"language-text\">INSERT</code>나 <code class=\"language-text\">UPDATE</code> 시점에 비용을 지불하는 방식으로 설계</li>\n</ul>\n<hr>\n<h2>8. 외래 키(Foreign Key)에 인덱스를 추가하지 않기</h2>\n<ul>\n<li>PostgreSQL은 외래 키에 자동으로 인덱스를 생성하지 않습니다. 따라서 <code class=\"language-text\">JOIN</code> 또는 <code class=\"language-text\">ON DELETE</code> / <code class=\"language-text\">ON UPDATE</code> 성능이 저하될 수 있습니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li>외래 키가 포함된 컬럼에 명시적으로 인덱스 추가</li>\n<li>삭제 및 갱신 작업 시 성능 저하를 방지하기 위해 정기적인 모니터링 수행</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> <span class=\"token keyword\">ON</span> orders <span class=\"token punctuation\">(</span>customer_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>9. <code class=\"language-text\">IS NOT DISTINCT FROM</code>을 인덱싱된 컬럼에 사용하기</h2>\n<ul>\n<li><code class=\"language-text\">IS NOT DISTINCT FROM</code>은 <code class=\"language-text\">NULL</code>을 비교할 때 유용하지만, 인덱스를 사용할 수 없게 만듭니다.</li>\n</ul>\n<h3>해결책</h3>\n<ul>\n<li>직접 <code class=\"language-text\">NULL</code> 비교 후 <code class=\"language-text\">=</code> 연산을 사용하는 방식으로 최적화</li>\n<li>쿼리 실행 계획을 분석하여 성능이 저하되는지 확인</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> foo\n<span class=\"token keyword\">WHERE</span> <span class=\"token punctuation\">(</span>bar <span class=\"token operator\">IS</span> <span class=\"token boolean\">NULL</span> <span class=\"token operator\">AND</span> baz <span class=\"token operator\">IS</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">OR</span> bar <span class=\"token operator\">=</span> baz<span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>결론</h2>\n<ul>\n<li>이 글에서 소개한 9가지 실수는 초기에는 문제가 되지 않지만, 데이터가 커질수록 심각한 성능 문제로 이어질 수 있습니다.</li>\n<li>PostgreSQL을 확장 가능한 방식으로 운영하려면, 처음부터 적절한 설정과 패턴을 선택하는 것이 중요합니다.</li>\n</ul>","frontmatter":{"title":"PG 주의사항","date":"January 30, 2025","description":"PG 주의사항","category":["DB"]}},"previous":{"fields":{"slug":"/pattern/애플리케이션의_CQRS/"},"frontmatter":{"title":"애플리케이션의 CQRS","category":["pattern"]}},"next":{"fields":{"slug":"/etc/Fine_Engineer의_조건-신념_철학_패러다임/"},"frontmatter":{"title":"Fine Engineer가 되기 위한 조건: 신념, 철학, 패러다임","category":["etc","고찰","book"]}}},"pageContext":{"id":"635243b3-cb2c-588d-8709-a7bc7ba1968c","previousPostId":"c6b5a64f-856e-5839-ad86-3b2f287690eb","nextPostId":"89465b8a-5a75-59f1-97ff-038726e9d41d"}},"staticQueryHashes":["1408108323","3764592887","62622001"],"slicesMap":{}}