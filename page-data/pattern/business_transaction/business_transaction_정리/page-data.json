{"componentChunkName":"component---src-templates-blog-post-js","path":"/pattern/business_transaction/business_transaction_정리/","result":{"data":{"site":{"siteMetadata":{"title":"Iol-lshh's","siteUrl":"https://iol-lshh.github.io"}},"markdownRemark":{"id":"189fd50d-03de-523c-ae0f-dbd45f53ebf8","excerpt":"비즈니스 트랜잭션은 시스템 트랜잭션과 다르다. 마틴 파울러의 POEAA는 이 둘을 다음으로 설명한다. 시스템 트랜잭션: 애플리케이션에서 데이터베이스로 수행 비즈니스 트랜잭션: 사용자에게서 애플리케이션으로 수행 시스템 트랜잭션은 트랜잭션하면 바로 떠오르는 그거다. 동기적으로 ACID…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/437a1/header.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.45569620253164%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACy0lEQVR42j1SS08aURSeRRdNU1sF8QGjMMjAoEwrWnCGcR4OA1JFkMcAMzjKQ1S02IBa4/tVH2lCUtPa2JiYbrrQTXd1002Tpv+h/6bHapp8uTnn5nznfN+9B8E4xUTLRiqJ+mQIbuGTO5iUhc3gUp4IlWz+KbNPhtRIpzoGFYxXIAaY2QyC+lKCWuWVau/oNBWfd4dn3OESIWnA6eIzhh4BFyHOoXTC3j/U7mKN3piVz1o4FeNUpM0bV14fbNYvl47Oy1vvl48/1w7P4+XtNipl4ZT2vlD3yAwZrzn92d8Xb68Oa/hgwsypVl7F+CxiopJidkl+tZdY2B0trkVntxLzu9rySaS0EZ7ZwQMFOyBYhOqbT4d/vp13CaqZVSCF1ghKy4xcSVUOKnsf4uUdbelYrR6Nz20nF/ZG8qudYB4U8oqhb2wglDmpf9QRbHv/CGgG24iRSkja8uq7CxBMSJPPI+Wl06vsxlmrJ6bvj0IFvCgM0Tk5MEwKsae2gSacRqn47eROJt0dzHnGy3CidNKfW69f/zz5+sNEsl4xahWyKJM2eqM6O92IU0+sniYH02SnW3uDoAjpYNLwwkNqVVCqbKoSnt3Zv/xeO71W5eTN2T46mLEJahs5ZCD9eicL/EY7rXdyBlK0sODZJ1Ox+bHSRij3hk0twp9R8mJPcDKnFSbyZaeo/vpSfykXDJ54uztocN12ae4RTN4Ixqu35IFYOTqzMVpY6w2XXKFiMxl4jL14iFEPMJ+DTaxUFl2S1sFksLvdGEx3+XPAvF8ST3RubHotOLkSm92MlNZbSbERp/WET++gG6yeR4S/k4XFygKAYB8uucZrYBi6IBg/4ZDy3cNFIpAnggW7NKnv5nQEo3MwoNDYP2pmkl1DmvUfMEHDA0WAVZyCGGkhRXDS3PMfwhOsr8HibjC7G20DLc8kKLiD4Q5g23V/8xfUitYyKAZeGgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/dc87c/header.avif 158w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/383b4/header.avif 315w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/d0061/header.avif 630w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/20e2c/header.avif 945w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/9eba6/header.avif 1260w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/c68af/header.avif 1536w\"\n              sizes=\"(max-width: 630px) 100vw, 630px\"\n              type=\"image/avif\"\n            /><source\n              srcset=\"/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/5787a/header.webp 158w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/89f54/header.webp 315w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/4d353/header.webp 630w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/0f41d/header.webp 945w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/f27a3/header.webp 1260w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/a8642/header.webp 1536w\"\n              sizes=\"(max-width: 630px) 100vw, 630px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/dda05/header.png 158w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/679a3/header.png 315w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/50637/header.png 630w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/fddb0/header.png 945w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/f46b1/header.png 1260w,\n/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/437a1/header.png 1536w\"\n            sizes=\"(max-width: 630px) 100vw, 630px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/4cb500d6424ae9e7ac3e6eb3f1c40a01/50637/header.png\"\n            alt=\"header\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>비즈니스 트랜잭션은 시스템 트랜잭션과 다르다. 마틴 파울러의 <a href=\"https://iol-lshh.github.io/%ED%9A%8C%EA%B3%A0/EAA/EAA_%EC%A0%95%EB%A6%AC/\">POEAA</a>는 이 둘을 다음으로 설명한다.</p>\n<ul>\n<li>시스템 트랜잭션: 애플리케이션에서 데이터베이스로 수행</li>\n<li>비즈니스 트랜잭션: 사용자에게서 애플리케이션으로 수행</li>\n</ul>\n<p>시스템 트랜잭션은 트랜잭션하면 바로 떠오르는 그거다. 동기적으로 ACID로 처리되어야 하는 것. 비즈니스 트랜잭션은 조금 다르다. <strong>최종적 일관성</strong>을 갖고 비동기적으로 처리될 수도 있다. 중요한 것은 <strong>사용자로부터 요청을 일관된 유스케이스 로직으로 처리</strong>한다는 것이다.</p>\n<p>비즈니스 트랜잭션을 설명하기 위해 다음 내용들을 정리할 것이다.</p>\n<ul>\n<li>동기(Synchronous)와 비동기(Asynchronous)</li>\n<li>블로킹(Blocking)과 논블로킹(Non-Blocking)</li>\n<li>동기화(Synchronization)</li>\n</ul>\n<hr>\n<h2>동기(Synchronous) vs 비동기(Asynchronous)</h2>\n<p>애플리케이션 단에서 동기와 비동기를 각각 한문장으로 정리하면 다음과 같다.</p>\n<ul>\n<li><strong>동기</strong>(Synchronous): 요청하면 처리하고 알려줌.\n<ul>\n<li>요청 → 처리 → 결과가 확정되기 전까지 다음 단계 X</li>\n</ul>\n</li>\n<li><strong>비동기</strong>(Asynchronous): 요청하면 처리하겠다고 알려주고, 처리함.\n<ul>\n<li>요청 → 바로 응답 → 실제 처리와 결과 확정은 나중에</li>\n</ul>\n</li>\n</ul>\n<p>뭔가 이렇게 봤을때 동기와 비동기에 대해 이렇게 정의해 볼 수 있을 것 같다.</p>\n<ul>\n<li><strong>동기</strong>는 로직의 <strong>흐름 자체가 차례로 이어지는 구조</strong></li>\n<li><strong>비동기</strong>는 로직의 <strong>흐름을 기다리지 않고 갈라지는 구조</strong></li>\n</ul>\n<p><strong>동기는 ‘흐름의 질서’이고, 비동기는 ‘흐름의 독립’이다.</strong> (데이터 일관성에서의 독립이 아니다!)</p>\n<p>또한 동기와 비동기는 블로킹/논블로킹과 같이 이야기 되어야 한다.</p>\n<hr>\n<h2>블로킹(Blocking) vs 논블로킹(Non-Blocking)</h2>\n<p>먼저 동기/비동기와 블로킹/논블로킹을 간단히 비교하면 다음과 같다.</p>\n<ul>\n<li><strong>동기/비동기</strong>는 호출에 대해 <strong>응답하는 방식</strong>이다.</li>\n<li><strong>블로킹/논블로킹</strong>은 루틴의 처리에서 <strong>대기 상황에 대한 대응 방식</strong>이다.</li>\n</ul>\n<p><strong>대기</strong>란 <strong>결과를 기다리는 동안 아무것도 못하고 멈추는 상태</strong>를 의미한다.</p>\n<ul>\n<li>I/O 대기. 데이터 올 때까지 멈춤 (디스크 읽기, 네트워크 응답, 파일 쓰기 등)</li>\n<li>다른 쓰레드가 끝날 때까지 대기 (<code class=\"language-text\">Thread.join()</code>)</li>\n<li>락 획득, 다른 작업 단위가 잡고 있으면 대기</li>\n<li>조건 만족될 때까지 대기 (<code class=\"language-text\">sleep(5)</code> 호출)</li>\n</ul>\n<p>I/O건 CPU건, 쓰레드건 상관없다. 중요한건 그것을 대기 상태라고 정의했는가 이다. 그리고 이런 대기 방식에 대해 블로킹/논블로킹이 적용된다.</p>\n<ul>\n<li><strong>블로킹</strong>(Blocking): 루틴이 끝나서 결과 나올 때까지 기다린다. 그동안 다른 일을 하지 않는다.</li>\n<li><strong>논블로킹</strong>(Non-Blocking): 루틴이 대기를 만나는 시점에 바로 반환한다. 결과가 없으면 “아직 없어!” 하고 끝난다.</li>\n</ul>\n<p>동기/비동기와 블로킹/논블로킹을 조합해보면 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>블로킹</th>\n<th>논블로킹</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>동기</strong></td>\n<td>대기할 것 다 기다려가며, <strong>순차적으로 실행</strong>한다.</td>\n<td>논블로킹의 대기는 결과 처리가 없으면 없다고 바로 반환하는데, 결과가 필요하므로, 결과를 받을때까지 <strong>반복해서 요청</strong>(polling)하는 경우다.</td>\n</tr>\n<tr>\n<td><strong>비동기</strong></td>\n<td>작업은 독립적으로 처리한다. 결과가 필요한 시점(async - await)이 생기면 기다린다.</td>\n<td>요청 접수 응답을 받고, 작업은 독립적으로 처리한다. 결과는 <strong>콜백, 이벤트 등으로 나중에 전달</strong> 받는다.</td>\n</tr>\n</tbody>\n</table>\n<p>비동기가 조금 헷갈리는데, JavaScript async-await을 떠올려보면 된다.</p>\n<ul>\n<li>async의 전체 흐름은 비동기다. (비동기 + 논블로킹)</li>\n<li>하지만 await 관점에서는 <strong>일시적으로 동기처럼 멈추는 구간</strong>이다. (비동기 + 블로킹)</li>\n<li>async - await은 \"<strong>대기를 만나면, 나는 이 친구 기다려서 독립적으로 실행할꺼야! 알아서 할일들 해</strong>\" 하는 선언이다.</li>\n</ul>\n<hr>\n<p>동기/비동기, 블로킹/논블로킹은 실행 흐름의 스타일을 설명하는 개념이다.</p>\n<p>이런 흐름은 내부적으로는 동기화(Synchronization)라는 타이밍 제어로 구현된다. 동기화는 순서를 맞추고, 충돌을 방지하며, 동작의 일관성을 만든다.</p>\n<h2>동기화(Synchronization)</h2>\n<p>동기화는 동시성 시스템에서의 타이밍 조율이다. 이는 <strong>일관성을 위한 흐름 제어</strong>를 목적으로 한다.</p>\n<blockquote>\n<p> 동기화(Synchronization)란 <strong>시스템이 조화를 이루어 작동하도록 이벤트를 조율하는 것</strong>을 말합니다. 예를 들어, 오케스트라의 지휘자(conductor)는 오케스트라가 동기화(synchronized)되거나 <strong>일정한 시간(in time)에 맞춰 연주하도록 조율</strong>합니다. 모든 부분이 동시에 작동하는 시스템은 동기적(synchronous) 또는 \"동기화된(in sync)\" 상태라고 하며, 그렇지 않은 경우를 <a href=\"https://en.wikipedia.org/wiki/Asynchronous_system\" title=\"비동기 시스템\">비동기</a>적(asynchronous)이라고 합니다. - <a href=\"https://en.wikipedia.org/wiki/Synchronization\">동기화</a></p>\n</blockquote>\n<p>컴퓨터 과학 관점에서 조금더 세부적으로 정의를 찾아보면 다음과 같다.</p>\n<blockquote>\n<p>동기화는 합의에 도달하거나 특정 일련의 동작을 수행하기 위해 여러 프로세스(multiple process)가 특정 지점에서 결합(join up)하거나 핸드셰이크(handsake) 하도록 조정(coordinating)하는 작업입니다. - <a href=\"https://en.wikipedia.org/wiki/Synchronization_(computer_science)\">동기화(컴퓨터 과학)</a></p>\n</blockquote>\n<p>동기화란 <strong>동시성(Concurrency) 시스템</strong>에서 여러 실행 단위(프로세스/스레드)가 <strong>의도한 올바른 순서로 작업을 수행</strong>하게 만드는 기술이다.</p>\n<ul>\n<li>“<strong>이 루틴 끝날 때까지 기다릴까?</strong>” → 동기/비동기</li>\n<li>“<strong>여러 작업이 수행 되는데, 누가 먼저?</strong>” → 동기화</li>\n</ul>\n<p>그렇다면 동기화는 어디에 필요할까?</p>\n<h3>동기화가 필요한 곳</h3>\n<p>동기화는 결국 <strong>동작 시점</strong>에 대한 이야기다. 실행 순서를 정렬한다거나, 자원 획득을 기다리게 한다거나 하는 것이 목적이다. 크게 분류해보면 같다.</p>\n<ul>\n<li>포크 - 조인 (Forks - Joins)</li>\n<li>생산자 - 소비자 (Producer - Consumer)</li>\n<li>배타적 자원 (Exclusive use resources)</li>\n</ul>\n<h4><a href=\"https://en.wikipedia.org/wiki/Fork%E2%80%93join_model\" title=\"포크-조인 모델\">포크 - 조인</a> (Forks - Joins)</h4>\n<p>로직이 포크(Fork)와 조인(Join)의 형태를 갖춘다면 동기화가 필요하다.</p>\n<ul>\n<li><strong>포크</strong>(Fork): 하나의 작업을 다수의 하위 작업으로 분할하는 것</li>\n<li><strong>조인</strong>(Join): 다수의 작업을 하나의 작업으로 합치는 것</li>\n</ul>\n<p>작업이 <strong>포크</strong>된다는 것은 <strong>다수의 하위 작업으로 분할한다는 것</strong>이다. 모든 하위 작업이 끝날때까지 대기하여, 작업의 결과를 전부 조인하고, 이후 로직을 실행해야 할 것이다. 이때, 포크 이후의 <strong>하위 작업들을 동시에 작업할 수도 있을 것</strong>인데, 조인 이후의 처리를 위해서는 하위 작업들이 전부 처리될 때까지 <strong>타이밍을 기다려야 할 것</strong>이다.</p>\n<h4><a href=\"https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem\" title=\"생산자-소비자 문제\">생산자 - 소비자:</a> (Producer - Consumer)</h4>\n<p>로직이 생산자와 소비자로 분리되어 처리된다면 동기화가 필요하다,.</p>\n<ul>\n<li><strong>생산자</strong>(Producer): 데이터를 만드는 주체</li>\n<li><strong>소비자</strong>(Consumer): 데이터를 소비하는 주체</li>\n</ul>\n<p>생산자-소비자 관계에서 소비자 프로세스는 필요한 데이터가 생성될 때까지 생산자 프로세스에 종속된다. <strong>두 주체가 동시에 작업할 수도 있을 것</strong>인데, 생산자가 데이터 생성할 때까지, 소비자는 <strong>타이밍을 기다려야 할 것</strong>이다.</p>\n<h4>배타적 자원 (Exclusive use resources)</h4>\n<p>흔히 동기화에 대해 이야기할 때, 동시성 이슈와 관련된 대표적인 동기화가 필요한 곳이다. 여러 실행 단위들이 특정 리소스에 의존하고 <strong>해당 리소스에 접근할 경우</strong>, 한 시점에 단 하나의 실행 단위 만이 해당 리소스에 접근해야 한다. 이때 <strong>실행 단위들은 동시에 작업할 수도 있을 것</strong> 인데, 자신의 차례가 올 때까지 <strong>타이밍을 기다려야 할 것</strong>이다.</p>\n<p>세 가지 경우를 모두 분석해보았을 때, 각 작업들 자체를 직렬적인 작업으로 수행할 수도 있다. 하지만 운영체제와 시스템에 있어, 동시성을 사용하지 않는다는 것은 매우 비효율적이다. 운영체제는 가상화를 통해 한정적인 CPU를 무한하게 보이도록 설계되었다. 한번에 여러 작업을 동시에 수행하는 것 처럼 보이도록 설계되어, 작업의 효율성을 높였다. 이런 주어진 자원을 사용하지 않을 이유가 없다. <strong>동시성을 사용하되, 동기화를 통해 시스템의 일관성을 달성하는 것이 소프트웨어 엔지니어링의 목표</strong>일 것이다.</p>\n<p>이런 동기화 개념은 단일 시스템 안에서는 락이나 세마포어 같은 저수준 기술로 구현되지만, 비즈니스 트랜잭션처럼 복잡한 서비스 간 흐름에서는 보다 고수준의 흐름 제어 방식이 필요하다.</p>\n<p>지금까지 정리한 동기화, 동기/비동기, 블로킹/논블로킹 모든 개념을 가지고, 그 복잡한 흐름의 실체인 비즈니스 트랜잭션을 살펴보자.</p>\n<hr>\n<h2>비즈니스 트랜잭션</h2>\n<p><strong>비즈니스 트랜잭션</strong>은 사용자 요청을 받아 여러 단계를 거쳐 처리되는 <strong>논리적 트랜잭션 흐름</strong>을 의미한다. 하나의 요청이 여러 마이크로서비스, 데이터베이스, 외부 시스템을 통과할 수 있으며, 이 복잡한 흐름 속에서도 <strong>사용자 관점에서 ‘동기 + 블로킹’처럼 느껴지는 예측 가능한 흐름</strong>이 필요하다. 실제 구현은 대부분 <strong>비동기 + 논블로킹</strong>으로 처리 되더라도, 다음 목표를 달성해야 한다.</p>\n<ul>\n<li>결과는 정해진 <strong>순서</strong>대로 도달해야 한다.</li>\n<li>결과는 <strong>중복되지 않아야</strong> 한다.</li>\n<li>결과를 <strong>되돌릴 수 있어야</strong>한다.</li>\n</ul>\n<p>시스템 트랜잭션은 락으로 동기화를 해결하지만, 비즈니스 트랜잭션에서는 한계가 있다. 단일 데이터베이스가 아닌 여러 서비스와 외부 시스템을 아우르는 복잡한 흐름을 다루기 때문이다. 여기서의 동기화는 <strong>단순히 타이밍 조절과 일관성을 넘어, 서비스 간 독립성도 유지해야 한다</strong>. 기존 락 기반 접근으로는 이를 충족하기 어렵기에, 새로운 방안이 제안된다. 바로 사가(Saga)다.</p>\n<h3>사가 (Saga)</h3>\n<p>사가(Saga)는 <strong>각 단계가 독립적이면서 전체적으로 일관성을 달성하는 트랜잭션 설계 방식</strong>이다. 동기화 개념을 비즈니스 트랜잭션에서 실현하는 것인데, <strong>트랜잭션을 작은 단위의 지역 트랜잭션으로 분리하고</strong>, 각 단계의 성공/실패 여부에 따라 <strong>다음 단계를 진행하거나 보상 처리</strong>한다.</p>\n<p>또한 사가는 비동기 + 논블로킹 구조와 잘 어울린다.</p>\n<p>비동기 이점</p>\n<ul>\n<li>서비스 간 <strong>느슨한 연결(loose coupling)</strong> 가능.</li>\n<li>장애 시에도 전체 플로우가 <strong>멈추지 않음</strong>.</li>\n<li>사가의 핵심 개념 중 하나인 <strong>보상 트랜잭션</strong>도 이벤트 기반으로 처리 가능.</li>\n</ul>\n<p>논블로킹 이점</p>\n<ul>\n<li>서비스는 <strong>“결과가 나올 때까지 아무것도 못하는 상황”이 없음</strong>.</li>\n<li>동시성(concurrency)과 처리량(throughput)이 올라감.</li>\n<li>타임아웃 지옥이나 동기적 장애 전파를 피할 수 있음.</li>\n</ul>\n<p>그렇다면 이 비동기 + 논블로킹 구조를 어떻게 전체 시스템에 걸쳐 구현할까?</p>\n<ul>\n<li>서비스 구성: 이벤트 수신자와 로컬 트랜잭션</li>\n<li>사가 코디네이터 - 오케스트레이터 vs 코레오그래피</li>\n<li>메시지 브로커 구축</li>\n<li>추적 시스템</li>\n</ul>\n<p>이때 서비스는 다음 두 가지로 구성된다.</p>\n<ul>\n<li><strong>이벤트 수신자</strong>: 특정 이벤트를 구독하고 반응하는 리스너로 메시지 브로커와 연결된다. 메시지를 받아 <strong>논블로킹 방식으로 처리 시작</strong>한다.</li>\n<li><strong>로컬 트랜잭션</strong>: 자기 책임에 해당하는 비즈니스 로직 실행한다. 서비스는 결과를 리턴하지 않고, 이벤트로 알린다.\n<ul>\n<li>처리 완료되면 → <strong>다음 단계로 이어지는 이벤트 발행</strong></li>\n<li>실패하면 → <strong>보상 이벤트 발행</strong></li>\n</ul>\n</li>\n</ul>\n<p>사가는 메시지 브로커와 이벤트를 수행하는 구조를 통해 이벤트 드리븐 아키텍처(Event Driven Architecture, EDA)를 구성하고, 이를 통해 비즈니스 트랜잭션에서의 동기화를 구현한다.</p>\n<p>(이 글에서는 사가를 아주 간략하게 비즈니스 트랜잭션 관점에서 살펴봤다. 조만간 크리스 리처드슨의 MSA 책을 읽고 정리한 글에서 더 자세히 정리할 것이다.)</p>\n<hr>\n<p><strong>비즈니스 트랜잭션</strong>은 사용자 요청을 받아 여러 단계를 거쳐 처리되는 논리적 트랜잭션이다. 시스템 트랜잭션처럼 단일 DB 안에서 끝나지 않고, 여러 서브 시스템, 메시지 큐, 외부 API, 데이터 저장 등을 포함하는 <strong>복잡하고 긴 처리 흐름</strong>을 가질 수 있다.</p>\n<p>이런 비즈니스 트랜잭션의 흐름에서는 <strong>동기/비동기</strong>, <strong>블로킹/논블로킹</strong> 구조를 상황에 맞게 조합하고, 각 단계 간의 적절한 <strong>동기화</strong>(synchronization) 설계로 <strong>신뢰성과 성능을 동시에 확보</strong>해야 한다. 이 때 서비스간 로직이 심화된다면, 사가의 도입을 고려해 볼 만 하다.</p>\n<p>중요한 것은 <strong>사용자 관점에서 모든 흐름이 순차적이며 동기적인 인터페이스</strong>로 느껴져야 한다. 바로 이것이 <strong>최종적 일관성(eventual consistency)을 달성하는 핵심 전략</strong>이며, 비즈니스 트랜잭션의 본질이다.</p>","images":null,"frontmatter":{"title":"Business Transaction 정리","date":"April 10, 2025","description":"Synchronous/Asynchronous, Block/Nonblock과 동기화(Synchronization) 대한 CS부터 비즈니스 트랜잭션까지","category":["pattern"],"featuredImage":null}},"previous":{"fields":{"slug":"/pattern/websocket/websocket_정리/"},"frontmatter":{"title":"웹소켓 정리","category":["pattern"]}},"next":null},"pageContext":{"id":"189fd50d-03de-523c-ae0f-dbd45f53ebf8","previousPostId":"47c24199-5629-5321-8456-562e0c73b719","nextPostId":null}},"staticQueryHashes":["1408108323","3764592887","62622001"],"slicesMap":{}}